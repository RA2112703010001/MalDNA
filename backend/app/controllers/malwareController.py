import os
import logging
import random
import uuid
from flask import request, jsonify, Blueprint, make_response
from werkzeug.utils import secure_filename
from flask_cors import CORS
from functools import wraps
from datetime import datetime
from flask_cors import cross_origin
from app.services.staticAnalysis import extract_opcodes, detect_obfuscation, extract_file_metadata
from app.services.dynamicAnalysis import DynamicAnalysisService
from app.services.hybridAnalysis import HybridAnalysisService
from app.models.malwareModel import MalwareModel, MalwareMetadata, BehaviorLog, DeepLearningClassification
from typing import Dict, List, Any, Optional
# Logging Config
from app.models.lineageModel import LineageModel
from app.models.mutationModel import MutationLineage
from app.services.lineageService import LineageAnalysisService
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Config
UPLOAD_FOLDER = os.getenv("UPLOAD_FOLDER", "/home/kali/MalDNA/dataset")
ALLOWED_EXTENSIONS = {"exe", "dll", "zip", "apk", "pdf", "docx"}
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

malware_bp = Blueprint("malware", __name__, url_prefix="/api/malware")
CORS(malware_bp, supports_credentials=True, resources={r"/*": {"origins": "*"}})

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

def validate_file_upload(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if "file" not in request.files and not (
            request.form.get("sample_id") or (request.json.get("sample_id") if request.is_json else None)
        ):
            return jsonify({"error": "No file or sample ID provided"}), 400
        return func(*args, **kwargs)
    return wrapper

from app.services.blockchainService import BlockchainService

# Instantiate BlockchainService
blockchain_service = BlockchainService()

@malware_bp.route("/upload", methods=["POST"], endpoint="upload_malware")
@cross_origin()
@validate_file_upload
def upload_malware():
    try:
        file = request.files.get("file")
        sample_id = request.form.get("sample_id") or (request.json.get("sample_id") if request.is_json else None)

        # If sample_id is not provided, generate one
        if not sample_id:
            sample_id = str(uuid.uuid4())

        # === Handle file or retrieve existing sample ===
        if file:
            filename = secure_filename(file.filename)
            file_path = os.path.join(UPLOAD_FOLDER, filename)
            file.save(file_path)
            logger.debug(f"File {filename} saved to {file_path}")
        else:
            sample = MalwareMetadata.objects(sample_id=sample_id).first()
            if not sample:
                logger.error(f"Sample not found with ID {sample_id}")
                return jsonify({"error": "Sample not found"}), 404
            file_path = sample.file_path
            filename = sample.filename
            logger.debug(f"File {filename} retrieved from sample metadata")

        # === Process and Log Malware Metadata ===
        logger.info(f"✅ Processing Malware: {filename}")

        # Generate unique reference IDs
        dna_referenceid = str(random.getrandbits(128))  # Can be set to 'unknown' if necessary
        file_hash = str(random.getrandbits(128))  # Replace with actual hashing logic

        # Save Malware Metadata into MongoDB
        malware_metadata = MalwareMetadata(
            sample_id=sample_id,
            filename=filename,
            file_path=file_path,
            os_version='Linux',
            architecture='x64',
            country_origin='US',
            collection_method='manual',
            threat_actor='Unknown',
            detection_status='not_detected',
            timestamp=datetime.utcnow(),
            dna_referenceid=dna_referenceid  # Ensuring dna_referenceid is set here
        )
        malware_metadata.save()
        logger.debug(f"Malware metadata saved for {filename}")

        # === Save MalwareModel entry ===
        malware_doc = MalwareModel(
            sample_id=sample_id,
            file_hash=file_hash,
            name=filename,
            dna_referenceid=dna_referenceid,  # Ensuring dna_referenceid is set here
            file_type="PE",
            file_size=os.path.getsize(file_path),
            analysis_status="pending"
        )
        malware_doc.save()
        logger.debug(f"MalwareModel entry saved for {filename}")

        # === Blockchain Verification ===
        try:
            # Blockchain verification (call to BlockchainService)
            blockchain_verification_result = blockchain_service.update_blockchain_status(malware_metadata, "pending")
            logger.debug(f"Blockchain verification result: {blockchain_verification_result}")
        except Exception as blockchain_error:
            logger.error(f"Blockchain verification failed for sample {sample_id}: {blockchain_error}")

        # === Return Success Response for Upload ===
        response_data = {
            "message": "Malware uploaded and metadata saved successfully",
            "filename": filename,
            "sample_id": sample_id
        }
        return make_response(jsonify(response_data), 200)

    except Exception as e:
        logger.error(f"❌ Malware processing error: {e}")
        return jsonify({"error": str(e)}), 500


@malware_bp.route("/static_analysis", methods=["POST"])
@cross_origin()
def static_analysis():
    try:
        # === Step 1: Validate JSON input ===
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data received"}), 400

        filename = data.get("filename")
        if not filename:
            return jsonify({"error": "Filename is required"}), 400

        # === Step 2: Retrieve Sample from DB ===
        sample = MalwareMetadata.objects(filename=filename).first()
        if not sample:
            return jsonify({"error": "Sample not found"}), 404

        # === Step 3: Run Static Analysis ===
        result = run_static_analysis(sample.file_path, sample.filename)

        # === Step 4: Handle Errors or Return Result ===
        if result.get("error"):
            return jsonify({"error": "Static analysis failed", "details": result["error"]}), 500

        logger.info(f"✅ Static analysis API success for: {filename}")
        return jsonify({
            "message": "Static analysis completed successfully",
            "filename": filename,
            "result": result
        }), 200

    except Exception as e:
        logger.error(f"❌ Static analysis API exception: {e}")
        return jsonify({"error": "Internal server error", "details": str(e)}), 500

@malware_bp.route("/dynamic_analysis", methods=["POST"])
@cross_origin()
def dynamic_analysis():
    try:
        filename = request.json.get("filename")
        if not filename:
            return jsonify({"error": "Filename is required"}), 400

        # Fetch the sample metadata from the database using the filename
        sample = MalwareMetadata.objects(filename=filename).first()
        if not sample:
            return jsonify({"error": "Sample not found"}), 404

        # Run dynamic analysis with the file path and filename
        result = run_dynamic_analysis(sample.file_path, sample.filename)

        # If an error occurs during dynamic analysis, return the error
        if "error" in result:
            return jsonify({"error": result["error"]}), 500

        # Return the successful dynamic analysis result
        return jsonify(result), 200

    except Exception as e:
        logger.error(f"❌ Dynamic analysis API error: {e}")
        return jsonify({"error": str(e)}), 500

@malware_bp.route("/hybrid_analysis", methods=["POST"])
@cross_origin()
def hybrid_analysis():
    try:
        # Fetch the filename from the request JSON
        filename = request.json.get("filename")
        if not filename:
            return jsonify({"error": "Filename is required"}), 400

        # Fetch the sample from the database using the filename
        sample = MalwareMetadata.objects(filename=filename).first()
        if not sample:
            return jsonify({"error": "Sample not found"}), 404

        # Get the file path
        file_path = sample.file_path
        if not os.path.exists(file_path):
            return jsonify({"error": "File path does not exist"}), 404

        logger.info(f"✅ Starting hybrid analysis for: {filename} (File Path: {file_path})")

        try:
            # Call HybridAnalysisService to perform the analysis using the file path
            # Using file_path as parameter for analysis in HybridAnalysisService
            analysis_result = HybridAnalysisService().perform_analysis(file_path=file_path)
            
            # Ensure the result is a dictionary before accessing keys
            if not isinstance(analysis_result, dict):
                return jsonify({"error": "Unexpected analysis result format"}), 500

            # Collect the results: static, dynamic, hybrid, and DNA
            static_results = analysis_result.get("static_results", {})
            dynamic_results = analysis_result.get("dynamic_results", {})
            hybrid_features = analysis_result.get("hybrid_features", {})
            malware_dna = analysis_result.get("malware_dna", "")

        except Exception as e:
            logger.error(f"❌ Hybrid analysis failed for {filename}: {e}")
            return jsonify({"error": f"Failed to perform hybrid analysis: {str(e)}"}), 500

        # Respond with the detailed analysis results
        return jsonify({
            "message": "Hybrid analysis completed successfully",
            "filename": filename,
            "reportid": str(analysis_result.get("reportid", "")),
            "static_results": static_results,
            "dynamic_results": dynamic_results,
            "hybrid_features": hybrid_features,
            "malware_dna": malware_dna
        }), 200

    except Exception as e:
        logger.error(f"❌ Hybrid analysis API error: {e}")
        return jsonify({"error": f"An unexpected error occurred: {str(e)}"}), 500


def run_static_analysis(file_path, filename):
    try:
        # === Step 1: Extract Static Features ===
        opcodes = extract_opcodes(file_path)
        obfuscation = detect_obfuscation(file_path)
        metadata = extract_file_metadata(file_path)

        if not metadata:
            logger.error(f"❌ Metadata extraction failed for {filename}")
            return {"error": "Static metadata extraction returned None"}

        # Static Analysis Features with default handling
        entropy = safe_get(metadata, 'entropy', "0.0")
        file_sections = safe_get(metadata, 'file_sections', "")
        entry_point = safe_get(metadata, 'entry_point', "")
        packers_detected = safe_get(metadata, 'packers_detected', "")
        is_packed = safe_get(metadata, 'is_packed', "False")
        suspicious_strings = safe_get(metadata, 'suspicious_strings', "")
        obfuscated_strings = safe_get(metadata, 'obfuscated_strings', "")
        embedded_urls = safe_get(metadata, 'embedded_urls', "")
        embedded_ips = safe_get(metadata, 'embedded_ips', "")
        file_version_info = safe_get(metadata, 'file_version_info', "{}")
        company_name = safe_get(metadata, 'company_name', "None")
        product_name = safe_get(metadata, 'product_name', "None")
        file_version = safe_get(metadata, 'file_version', "None")
        original_filename = safe_get(metadata, 'original_filename', "None")
        imports = safe_get(metadata, 'imports', "")
        exports = safe_get(metadata, 'exports', "")
        resources = safe_get(metadata, 'resources', "")
        dll_characteristics = safe_get(metadata, 'dll_characteristics', "")
        import_hash = safe_get(metadata, 'import_hash', "")
        opcode_sequence = safe_get(metadata, 'opcode_sequence', "")
        suspicious_opcode_patterns = safe_get(metadata, 'suspicious_opcode_patterns', "")
        nopsled_detected = safe_get(metadata, 'nopsled_detected', "False")
        file_hashes = safe_get(metadata, 'file_hashes', "")

        # === Step 2: Update MongoDB Entry ===
        malware_metadata = MalwareMetadata.objects(filename=filename).first()
        if not malware_metadata:
            logger.error(f"❌ MalwareMetadata not found for {filename}")
            return {"error": "Malware metadata not found"}

        malware_metadata.update(
            set__opcodes=opcodes,
            set__obfuscation_detected=obfuscation,
            set__entropy=entropy,
            set__file_sections=file_sections,
            set__entry_point=entry_point,
            set__packers_detected=packers_detected,
            set__is_packed=is_packed,
            set__suspicious_strings=suspicious_strings,
            set__obfuscated_strings=obfuscated_strings,
            set__embedded_urls=embedded_urls,
            set__embedded_ips=embedded_ips,
            set__file_version_info=file_version_info,
            set__company_name=company_name,
            set__product_name=product_name,
            set__file_version=file_version,
            set__original_filename=original_filename,
            set__imports=imports,
            set__exports=exports,
            set__resources=resources,
            set__dll_characteristics=dll_characteristics,
            set__import_hash=import_hash,
            set__opcode_sequence=opcode_sequence,
            set__suspicious_opcode_patterns=suspicious_opcode_patterns,
            set__nopsled_detected=nopsled_detected,
            set__virus_total_detection={
                "total": safe_get(metadata.get('virus_total_detection', {}), 'total', ""),
                "positives": safe_get(metadata.get('virus_total_detection', {}), 'positives', ""),
                "scan_date": safe_get(metadata.get('virus_total_detection', {}), 'scan_date', ""),
                "detection_names": safe_get(metadata.get('virus_total_detection', {}), 'detection_names', ""),
            },
            set__file_hashes=file_hashes,
            set__processing_status="completed",
        )

        # === Step 3: Logging & Response ===
        logger.info(f"✅ Static Analysis Results Stored for: {filename}")
        return {
            "opcodes": opcodes,
            "obfuscation_detected": obfuscation,
            "entropy": entropy,
            "file_sections": file_sections,
            "entry_point": entry_point,
            "packers_detected": packers_detected,
            "is_packed": is_packed,
            "suspicious_strings": suspicious_strings,
            "obfuscated_strings": obfuscated_strings,
            "embedded_urls": embedded_urls,
            "embedded_ips": embedded_ips,
            "file_version_info": file_version_info,
            "company_name": company_name,
            "product_name": product_name,
            "file_version": file_version,
            "original_filename": original_filename,
            "imports": imports,
            "exports": exports,
            "resources": resources,
            "dll_characteristics": dll_characteristics,
            "import_hash": import_hash,
            "opcode_sequence": opcode_sequence,
            "suspicious_opcode_patterns": suspicious_opcode_patterns,
            "nopsled_detected": nopsled_detected,
            "virus_total_detection": {
                "total": safe_get(metadata.get('virus_total_detection', {}), 'total', ""),
                "positives": safe_get(metadata.get('virus_total_detection', {}), 'positives', ""),
                "scan_date": safe_get(metadata.get('virus_total_detection', {}), 'scan_date', ""),
                "detection_names": safe_get(metadata.get('virus_total_detection', {}), 'detection_names', ""),
            },
            "file_hashes": file_hashes,
        }

    except Exception as e:
        logger.error(f"❌ Static analysis failed for {filename}: {e}")
        return {"error": str(e)}

def safe_get(dictionary, key, default=None):
    """ Safely retrieves a value from a dictionary, returning a default value if the key is not found. """
    try:
        return str(dictionary.get(key, default))  # Convert the result to a string
    except (AttributeError, TypeError) as e:
        logger.error(f"Error accessing key '{key}' in dictionary: {str(e)}")
        return str(default)  # Ensure the default is returned as a string


def run_dynamic_analysis(file_path: str, filename: str) -> dict:
    """
    Function to run dynamic analysis using DynamicAnalysisService.
    This is the same as the logic you've defined in `DynamicAnalysisService`.
    """
    try:
        # Ensure the file path is valid
        DynamicAnalysisService.validate_file_path(file_path)

        # Generate the dynamic analysis report
        report = DynamicAnalysisService.generate_dynamic_analysis_report(file_path)
        
        if "error" in report:
            logger.error(f"Error in dynamic analysis for {filename}: {report['error']}")
            return {"error": report["error"]}

        return report
    except Exception as e:
        logger.error(f"Error during dynamic analysis for {filename}: {e}")
        return {"error": f"Error during dynamic analysis: {str(e)}"}

def run_hybrid_analysis(file_path: str, filename: str, sample_hash: Optional[str] = None) -> dict:
    try:
        logger.info(f"Starting hybrid analysis for file: {filename}")

        hybrid_service = HybridAnalysisService()

        # If sample_hash is provided, fetch features using the hash, otherwise perform file-based analysis
        if sample_hash:
            # Fetch features based on sample_hash and perform analysis
            result = hybrid_service.perform_analysis(file_path=sample_hash)  # Using sample_hash as the file_path
        else:
            # Perform analysis based on the file_path
            result = hybrid_service.perform_analysis(file_path=file_path)

        logger.info(f"Hybrid analysis completed for file: {filename}, Report ID: {result.get('reportid')}")

        # Check if the result contains any error message
        if 'error' in result:
            logger.error(f"Analysis failed for {filename}: {result['error']}")
            return {
                "filename": filename,
                "error": result['error']
            }

        # Constructing the final output based on the returned analysis results
        return {
            "filename": filename,
            "reportid": str(result.get("reportid")),
            "static_results": result.get("static_results", {}),
            "dynamic_results": result.get("dynamic_results", {}),
            "hybrid_features": result.get("hybrid_features", {}),
            "malware_dna": result.get("malware_dna", "")
        }

    except Exception as e:
        logger.error(f"Failed to run hybrid analysis for {filename}: {e}")
        return {
            "filename": filename,
            "error": str(e)
        }

@malware_bp.route("/classify/<string:filename>", methods=["POST"])
@cross_origin()
def classify_malware(filename):
    try:
        # Fetch malware metadata based on filename
        sample = MalwareMetadata.objects(filename=filename).first()

        if not sample:
            return jsonify({"error": "Sample not found"}), 404

        # Static analysis results (assuming these are being received in the request payload)
        metadata = request.get_json()

        # Update the metadata with validated static analysis results
        update_result = update_malware_metadata(metadata, filename)
        
        if "error" in update_result:
            return jsonify(update_result), 500

        # Classify the sample based on filename or other features
        classification_result = {
            "filename": filename,
            "prediction": "malicious" if "mal" in filename.lower() else "benign",
            "confidence": round(random.uniform(0.8, 0.99), 2)
        }

        logger.info(f"🔍 Malware Classification: {classification_result}")
        return jsonify({
            "classification": classification_result,
            "updated_metadata": update_result
        }), 200

    except Exception as e:
        logger.error(f"❌ Classification error: {e}")
        return jsonify({"error": str(e)}), 500

