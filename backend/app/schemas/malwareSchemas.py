import os
import json
import hashlib
import logging
import argparse
from datetime import datetime
from typing import List, Optional, Dict, Any

# Pydantic for Schema Validation
from pydantic import BaseModel, Field, validator

# MongoDB Integration
from mongoengine import Document, StringField, DateTimeField, DictField, ListField, IntField, ValidationError

# Configure Logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# --------------------------------------------
# 🎯 **Malware Metadata Schema**
# --------------------------------------------
class MalwareMetadataSchema(BaseModel):
    """Pydantic schema for uploaded malware metadata"""
    file_hash: str = Field(..., description="SHA256 hash of the malware sample")
    file_name: str = Field(..., description="Original filename of the sample")
    file_type: str = Field(..., description="File type (PE, ELF, Mach-O, APK, etc.)")
    file_size: int = Field(..., gt=0, description="Size of the file in bytes")
    uploaded_at: datetime = Field(default_factory=datetime.utcnow)
    uploader: Optional[str] = Field(None, description="User who uploaded the sample")

    @validator("file_hash")
    def validate_hash(cls, v):
        """Ensure file hash is a valid SHA256 hash"""
        if len(v) != 64 or not all(c in "0123456789abcdef" for c in v.lower()):
            raise ValueError("Invalid SHA256 hash")
        return v

    @validator("file_type")
    def validate_file_type(cls, v):
        """Ensure file type is valid"""
        allowed_types = ["PE", "ELF", "Mach-O", "APK", "Script", "Shellcode", "Macro", "Firmware"]
        if v not in allowed_types:
            raise ValueError(f"Invalid file type. Allowed types: {allowed_types}")
        return v

# --------------------------------------------
# 📌 **MongoDB Malware Sample Storage**
# --------------------------------------------
class MalwareSample(Document):
    """
    MongoDB model for storing uploaded malware samples.
    """
    sample_id = StringField(primary_key=True, required=True)
    file_hash = StringField(required=True, unique=True)
    file_name = StringField(required=True)
    file_type = StringField(required=True)
    file_size = IntField(required=True, min_value=1)
    uploaded_at = DateTimeField(default=datetime.utcnow)
    uploader = StringField()
    classification_results = DictField(default={})
    analysis_status = StringField(choices=["pending", "in_progress", "completed"], default="pending")

    meta = {
        "collection": "malware_samples",
        "indexes": ["file_hash", "file_type", "-uploaded_at"]
    }

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert malware sample to a dictionary.
        """
        return {
            "sample_id": self.sample_id,
            "file_hash": self.file_hash,
            "file_name": self.file_name,
            "file_type": self.file_type,
            "file_size": self.file_size,
            "uploaded_at": self.uploaded_at.isoformat(),
            "uploader": self.uploader,
            "classification_results": self.classification_results,
            "analysis_status": self.analysis_status
        }

# --------------------------------------------
# 📌 **Malware Classification Response Validation**
# --------------------------------------------
class MalwareClassificationResponseSchema(BaseModel):
    """Pydantic schema for validating malware classification results"""
    sample_id: str = Field(..., description="Unique malware sample ID")
    classification: str = Field(..., description="Malware classification result")
    confidence_score: float = Field(..., ge=0, le=1, description="Confidence score (0-1)")
    risk_level: str = Field(..., description="Risk level of the malware")

    @validator("classification")
    def validate_classification(cls, v):
        """Ensure classification is valid"""
        allowed_classes = ["benign", "malicious", "suspicious"]
        if v not in allowed_classes:
            raise ValueError(f"Invalid classification. Allowed values: {allowed_classes}")
        return v

    @validator("risk_level")
    def validate_risk_level(cls, v):
        """Ensure risk level is valid"""
        allowed_levels = ["low", "medium", "high", "critical"]
        if v not in allowed_levels:
            raise ValueError(f"Invalid risk level. Allowed values: {allowed_levels}")
        return v

# --------------------------------------------
# 🔥 **CLI Utility for Malware Management**
# --------------------------------------------
def upload_malware_sample(file_path: str, uploader: Optional[str] = None) -> Dict[str, Any]:
    """
    Upload a malware sample and store it in MongoDB.
    """
    logger.info(f"🚀 Uploading malware sample from {file_path}...")

    # Validate File Exists
    if not os.path.exists(file_path):
        logger.error("❌ File not found!")
        return {"error": "File not found"}

    # Compute SHA256 Hash
    with open(file_path, "rb") as f:
        file_bytes = f.read()
        file_hash = hashlib.sha256(file_bytes).hexdigest()
    
    # Get File Metadata
    file_name = os.path.basename(file_path)
    file_size = os.path.getsize(file_path)
    file_type = "PE" if file_path.endswith(".exe") else "Unknown"

    # Validate Using Pydantic Schema
    metadata = MalwareMetadataSchema(
        file_hash=file_hash,
        file_name=file_name,
        file_type=file_type,
        file_size=file_size,
        uploader=uploader
    )

    # Store in MongoDB
    sample_id = f"malware_{file_hash[:8]}"
    malware_sample = MalwareSample(
        sample_id=sample_id,
        file_hash=file_hash,
        file_name=file_name,
        file_type=file_type,
        file_size=file_size,
        uploader=uploader
    )
    malware_sample.save()

    logger.info(f"✅ Malware sample {file_name} uploaded successfully!")
    return malware_sample.to_dict()

# --------------------------------------------
# 📌 **Retrieve Malware Samples**
# --------------------------------------------
def retrieve_malware_samples(limit: int = 10) -> List[Dict[str, Any]]:
    """
    Retrieve stored malware samples.
    """
    logger.info(f"📄 Retrieving last {limit} malware samples...")

    samples = MalwareSample.objects().order_by("-uploaded_at")[:limit]
    return [sample.to_dict() for sample in samples]

# --------------------------------------------
# 🔥 **CLI Argument Parser**
# --------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Malware Sample Management")

    subparsers = parser.add_subparsers(dest="command", required=True)

    # 📌 Upload Malware Sample
    upload_parser = subparsers.add_parser("upload", help="Upload a new malware sample")
    upload_parser.add_argument("--file_path", required=True, help="Path to the malware file")
    upload_parser.add_argument("--uploader", help="User uploading the sample")

    # 📌 Retrieve Malware Samples
    retrieve_parser = subparsers.add_parser("retrieve", help="Retrieve stored malware samples")
    retrieve_parser.add_argument("--limit", type=int, default=10, help="Number of samples to retrieve")

    args = parser.parse_args()

    # Execute Command
    if args.command == "upload":
        sample = upload_malware_sample(args.file_path, args.uploader)
        print(json.dumps(sample, indent=4))

    elif args.command == "retrieve":
        samples = retrieve_malware_samples(args.limit)
        print(json.dumps(samples, indent=4))
