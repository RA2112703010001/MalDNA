import os
import json
import argparse
import logging
from datetime import datetime
from mongoengine import DoesNotExist

# Models
from app.models.malwareModel import MalwareMetadata, MalwareAnalysisResult, BehaviorLog
from app.models.blockchainModel import BlockchainTransaction
from app.models.lineageModel import LineageModel

# Services
from app.services.staticAnalysis import extract_opcodes, detect_obfuscation, extract_file_metadata
from app.services.dynamicAnalysis import DynamicAnalysisService
from app.services.hybridAnalysis import HybridAnalysisService

# Blockchain Utils
from app.utils.blockchainUtils import (
    store_on_blockchain, classify_malware, vote_on_malware, get_reputation
)

# Dataset Utils
from app.utils.datasetUtils import (
    update_sample_label,
    log_label_change,
    log_dataset_version,
    get_sample_by_id
)

# Logging Config
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

RESULTS_DIR = os.getenv("RESULTS_DIR", "/home/kali/MalDNA/backend/reports/")
os.makedirs(RESULTS_DIR, exist_ok=True)

class MalwareService:
    """Core malware analysis and blockchain interaction service."""

    @staticmethod
    def fetch_malware_sample(malware_id):
        try:
            return MalwareMetadata.objects.get(id=malware_id)
        except DoesNotExist:
            logger.error(f"‚ùå Malware sample {malware_id} not found.")
            return None

    @staticmethod
    def run_static_analysis(file_path, filename):
        try:
            opcodes = extract_opcodes(file_path)
            obfuscation = detect_obfuscation(file_path)
            metadata = extract_file_metadata(file_path)

            MalwareMetadata.objects(filename=filename).update(
                set__opcodes=opcodes,
                set__obfuscation_detected=obfuscation,
                set__metadata=metadata
            )

            return {
                "opcodes": opcodes,
                "obfuscation_detected": obfuscation,
                "metadata": metadata
            }
        except Exception as e:
            logger.error(f"‚ùå Static analysis error: {e}")
            return {"error": str(e)}

    @staticmethod
    def run_dynamic_analysis(file_path, filename):
        try:
            sandbox_result = DynamicAnalysisService.execute_in_sandbox(file_path)
            api_calls = DynamicAnalysisService.monitor_api_calls(sandbox_result)
            BehaviorLog(filename=filename, api_calls=api_calls).save()
            return {"sandbox_result": sandbox_result, "api_calls": api_calls}
        except Exception as e:
            logger.error(f"‚ùå Dynamic analysis error: {e}")
            return {"error": str(e)}

    @staticmethod
    def run_hybrid_analysis(file_path, filename):
        try:
            heuristic = HybridAnalysisService.heuristic_analysis(file_path)
            ai_prediction = HybridAnalysisService.ai_behavior_prediction(file_path)

            MalwareMetadata.objects(filename=filename).update(
                set__heuristic_result=heuristic,
                set__ai_prediction=ai_prediction
            )
            return {"heuristic_result": heuristic, "ai_prediction": ai_prediction}
        except Exception as e:
            logger.error(f"‚ùå Hybrid analysis error: {e}")
            return {"error": str(e)}

    @staticmethod
    def analyze_malware(malware_id, dataset_id=None):
        malware = MalwareService.fetch_malware_sample(malware_id)
        if not malware:
            return None

        file_path = malware.file_path
        filename = malware.filename
        if not os.path.exists(file_path):
            logger.error(f"‚ùå File not found: {file_path}")
            return None

        logger.info(f"üîç Analyzing: {filename}")

        static = MalwareService.run_static_analysis(file_path, filename)
        dynamic = MalwareService.run_dynamic_analysis(file_path, filename)
        hybrid = MalwareService.run_hybrid_analysis(file_path, filename)

        # AI classification
        ai_result = classify_malware(file_path)
        classification = ai_result.get("classification", "unknown")
        MalwareMetadata.objects(id=malware_id).update(set__classification=classification)

        # Update dataset tracking and logs
        update_sample_label(str(malware_id), classification)
        log_label_change(str(malware_id), classification)
        if dataset_id:
            log_dataset_version(dataset_id)

        # Blockchain storage
        tx_hash = store_on_blockchain(
            file_path,
            malware_id=str(malware_id),
            classification=classification
        )

        # Save full result
        analysis_result = MalwareAnalysisResult(
            malware_id=malware_id,
            static_analysis=static,
            dynamic_analysis=dynamic,
            hybrid_analysis=hybrid,
            blockchain_tx=tx_hash,
            timestamp=datetime.utcnow()
        )
        analysis_result.save()

        BlockchainTransaction(
            malware_id=malware_id,
            transaction_hash=tx_hash,
            classification=classification,
            timestamp=datetime.utcnow()
        ).save()

        # Lineage tracking
        lineage_data = {
            "malware_id": malware_id,
            "genetic_signature": ai_result.get("dna_hash", "N/A"),
            "mutation_history": [],
            "risk_score": ai_result.get("risk_score", 0),
            "ai_prediction": classification
        }
        LineageModel(**lineage_data).save()

        logger.info(f"‚úÖ Complete analysis done and synced for: {filename}")
        return analysis_result

    @staticmethod
    def batch_process_malware(limit=5, dataset_id=None):
        logger.info(f"üöÄ Batch processing {limit} samples...")
        results = []
        for sample in MalwareMetadata.objects()[:limit]:
            result = MalwareService.analyze_malware(sample.id, dataset_id=dataset_id)
            if result:
                results.append(result)
        logger.info(f"‚úÖ Batch processing complete.")
        return results

    @staticmethod
    def vote_on_malware(malware_id, vote="malicious"):
        try:
            result = vote_on_malware(malware_id, vote)
            logger.info(f"üó≥Ô∏è Voted '{vote}' on {malware_id}")
            return result
        except Exception as e:
            logger.error(f"‚ùå Voting error: {e}")
            return {"error": str(e)}

    @staticmethod
    def get_reputation_score(entity_address):
        try:
            score = get_reputation(entity_address)
            logger.info(f"üìà Reputation of {entity_address}: {score}")
            return score
        except Exception as e:
            logger.error(f"‚ùå Reputation fetch error: {e}")
            return {"error": str(e)}

# ---------------------- CLI Commands ---------------------- #

def cli_fetch_malware(malware_id):
    sample = MalwareService.fetch_malware_sample(malware_id)
    if sample:
        print(json.dumps(sample.to_mongo().to_dict(), indent=4))
    else:
        print("[‚ùå] Malware sample not found.")

def cli_analyze_malware(malware_id, dataset_id=None):
    result = MalwareService.analyze_malware(malware_id, dataset_id)
    if result:
        print("[‚úî] Analysis complete and blockchain synced.")
    else:
        print("[‚ùå] Analysis failed.")

def cli_batch_process_malware(limit, dataset_id=None):
    results = MalwareService.batch_process_malware(limit=limit, dataset_id=dataset_id)
    print(f"[‚úî] Batch complete: {len(results)} samples.")

def cli_vote_malware(malware_id, vote):
    result = MalwareService.vote_on_malware(malware_id, vote)
    print(f"[üó≥Ô∏è] Vote result: {result}")

def cli_reputation(entity):
    score = MalwareService.get_reputation_score(entity)
    print(f"[üìä] Reputation score: {score}")

# ---------------------- Entry Point ---------------------- #

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MalwareService CLI")
    parser.add_argument("--fetch", metavar="MALWARE_ID", help="Fetch malware sample.")
    parser.add_argument("--analyze", nargs="+", metavar=("MALWARE_ID", "DATASET_ID"), help="Run full analysis.")
    parser.add_argument("--batch", nargs="*", metavar=("LIMIT", "DATASET_ID"), help="Run batch analysis.")
    parser.add_argument("--vote", nargs=2, metavar=("MALWARE_ID", "VOTE"), help="Vote on malware (malicious/benign).")
    parser.add_argument("--reputation", metavar="ADDRESS", help="Get reputation of blockchain entity.")

    args = parser.parse_args()

    if args.fetch:
        cli_fetch_malware(args.fetch)
    elif args.analyze:
        malware_id = args.analyze[0]
        dataset_id = args.analyze[1] if len(args.analyze) > 1 else None
        cli_analyze_malware(malware_id, dataset_id)
    elif args.batch:
        limit = int(args.batch[0]) if len(args.batch) > 0 else 5
        dataset_id = args.batch[1] if len(args.batch) > 1 else None
        cli_batch_process_malware(limit, dataset_id)
    elif args.vote:
        cli_vote_malware(args.vote[0], args.vote[1])
    elif args.reputation:
        cli_reputation(args.reputation)
    else:
        print("[‚ùå] Invalid CLI command.")

# ---------------------- External Analyzer ---------------------- #

def analyze_sample_and_store(file_path, malware_id=None, dataset_id=None):
    """
    Analyze a file path assuming already registered malware, and store results.
    """
    if not file_path or not os.path.exists(file_path):
        logger.error(f"‚ùå File path invalid or does not exist: {file_path}")
        return None

    try:
        malware = MalwareMetadata.objects(file_path=file_path).first()
        if not malware:
            logger.error(f"‚ùå No metadata found for file: {file_path}")
            return None

        logger.info(f"üöÄ Starting direct sample analysis for: {malware.filename}")
        return MalwareService.analyze_malware(malware.id, dataset_id=dataset_id)
    except Exception as e:
        logger.error(f"‚ùå analyze_sample_and_store error: {e}")
        return {"error": str(e)}

